```{r}

```

---
title: "sims"
format: html
editor: visual
---

## Quarto

```{r}
match.model = function(pop, methods, df.m) {
  m = length(methods)
  for (i in 1:m) {
    sample = methods[[i]] 
    marg.pop = pop$logmarg + log(pop$priorprobs)
    marg.sample = sample$logmarg + log(sample$priorprobs)
    loc = match( marg.sample, marg.pop)
    df.m[loc, i+1] = sample$postprobs
  }
  return(df.m)
}

bias = function(yhat, ytrue) {
  diff = abs(yhat -ytrue)
  mean(diff, na.rm = TRUE)
}

mse= function(yhat, ytrue) {
  diff = (yhat -ytrue)^2
  mean(diff, na.rm = TRUE)
}


```


Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

```{r}

data(UScrime, package="MASS")
#UScrime[,-2] = log(UScrime[,-2])
set.seed(42)
crime.amcmc =  bas.lm(log(y) ~ log(M) + So + log(Ed) + log(Po1) + log(Po2)
                    + log(LF) + log(M.F) + log(Pop) + log(NW) +
                      log(U1) + log(U2) + log(GDP) + log(Ineq) + log(Prob)+
                      log(Time), 
                    data=UScrime, n.models=2^15, prior="BIC", 
                    method = "AMCMC", burnin.iteration = 5000, 
                    MCMC.iterations = 5000, thin = 15, delta = .01, importance.sampling = FALSE, 
                    renormalize = FALSE)

plot(crime.amcmc$sampleprobs, crime.amcmc$postprobs.MCMC)
abline(0,1)

set.seed(42)
crime.ais =  bas.lm(log(y) ~ log(M) + So + log(Ed) + log(Po1) + log(Po2)
                      + log(LF) + log(M.F) + log(Pop) + log(NW) +
                        log(U1) + log(U2) + log(GDP) + log(Ineq) + log(Prob)+
                        log(Time), 
                      data=UScrime, n.models=2^15, prior="BIC", 
                      method = "AMCMC", burnin.iteration = 5000, 
                      MCMC.iterations = 5000, thin = 15, delta = .01, importance.sampling = TRUE)

plot(crime.ais$sampleprobs, crime.ais$postprobs.RN)
abline(0,1)

set.seed(42)
crime.mcmc = bas.lm(log(y) ~ log(M) + So + log(Ed) + log(Po1) + log(Po2)
                    + log(LF) + log(M.F) + log(Pop) + log(NW) +
                      log(U1) + log(U2) + log(GDP) + log(Ineq) + log(Prob)+
                      log(Time), 
                    data=UScrime, n.models=2^15, prior="BIC", 
                    method = "MCMC", burnin.iteration = 5000, 
                    MCMC.iterations = 5000, thin = 15, delta = .01, renormalize = FALSE)

plot(crime.mcmc$postprobs.MCMC, crime.mcmc$postprobs.RN)
abline(0,1)

crime.det = bas.lm(log(y) ~ log(M) + So + log(Ed) + log(Po1) + log(Po2)
                   + log(LF) + log(M.F) + log(Pop) + log(NW) +
                     log(U1) + log(U2) + log(GDP) + log(Ineq) + log(Prob)+
                     log(Time), 
                   data=UScrime, n.models=2^15, prior="BIC", 
                   method = "deterministic")
 
df = data.frame(TRUTH=crime.det$probne0.RN,AIS = crime.ais$probne0.RN, AMCMC=crime.ais$probne0.MCMC, 
                MCMC=crime.mcmc$probne0.MCMC)                  
plot(df)

cor(df)




df.m = data.frame(TRUTH = crime.det$postprobs.RN, AIS=NA, AMCMC=NA, MCMC=NA)
df.mod = match.model(crime.det, list(crime.ais, crime.amcmc, crime.mcmc), df.m)
plot(df.mod)

```


```{r}
data(tecator, package="FuncNN")
# Extract data and target
X <- tecator$absorp.fdata$data[1:172,]
fat <- tecator$y$Fat[1:172] 
data = data.frame(fat, X)

subsamp = seq(1,100, by=4)
p = length(subsamp)
b.it = 2000000
mc.it = 2000000
set.seed(42)

tecator.det = bas.lm(fat ~ ., data=data[, c(subsamp,101)], prior="g-prior", alpha = 100,
                     method = "deterministic", thin = 100,
                     burnin.iterations = b.it,
                      MCMC.iterations = mc.it,
                      delta = 0.01, n.models = 2^p)

df = data.frame(TRUTH = tecator.det$probne0)

set.seed(42)
tecator.IS = bas.lm(fat ~ ., data=data[, c(subsamp,101)], prior="g-prior", alpha = 100, 
                     method = "AMCMC", 
                     burnin.iterations = b.it, thin=100,
                     MCMC.iterations = mc.it,  lambda = 102, # renormalize = TRUE,
                     delta = 0.01, n.models = 2^19, importance.sampling = TRUE)
plot(tecator.IS$sampleprobs, tecator.IS$postprobs.RN)

set.seed(42)
tecator.amc = bas.lm(fat ~ ., data=data[, c(subsamp,101)], prior="g-prior", alpha = 100, 
                     method = "AMCMC", 
                     burnin.iterations = 2000000, thin = 100,
                     MCMC.iterations = 2000000, lambda = 102,
                     delta = 0.01, n.models = 2^19, importance.sampling = FALSE)
#plot(tecator.amc$sampleprobs, tecator.amc$postprobs.MCMC)
#plot(tecator.amc$postprobs.RN, tecator.amc$postprobs.MCMC)
#abline(0,1)

plot(tecator.IS$probne0, tecator.amc$probne0)

set.seed(42)
tecator.mcmc = bas.lm(fat ~ ., data=data[, c(subsamp,101)], prior="g-prior", alpha = 100, method = "MCMC", 
                     burnin.iterations = b.it, thin = 100,
                     MCMC.iterations = mc.it,
                     delta = 0.01, n.models = 2^19)
#plot(tecator.mcmc$postprobs.RN, tecator.mcmc$postprobs.MCMC)

plot(tecator.mcmc$probne0.MCMC, tecator.IS$probne0)
abline(0,1)

tecator.probne0 = data.frame(TRUTH=tecator.det$probne0, HT = tecator.IS$probne0, AMC = tecator.amc$probne0.MCMC, 
                             MCMC=tecator.mcmc$probne0.MCMC)
plot(tecator.probne0)
cor(tecator.probne0)

df.mod = data.frame(TRUTH = tecator.det$postprobs.RN, AIS=NA, AMCMC=NA, MCMC=NA)
tecator.modelprobs = match.model(tecator.det, list(tecator.IS, tecator.amc, tecator.mcmc), df.mod)
plot(tecator.modelprobs)
cor(tecator.modelprobs, use = "pair")

```
```{r}
apply(tecator.modelprobs,2, bias, tecator.modelprobs$TRUTH)
apply(tecator.modelprobs,2, var, tecator.modelprobs$TRUTH, na.rm=TRUE)
```


```{r}
```

